// @version=5
strategy("MTF Supply/Demand Zone-Rejection Strategy (v1)",
     overlay=true, max_bars_back=5000, calc_on_every_tick=true,
     initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.01)

//==================== Inputs ====================//
tfHTF            = input.timeframe("60", "HTF for Zones")
leftBars         = input.int(5, "Pivot Left", minval=1)
rightBars        = input.int(5, "Pivot Right", minval=1)
zoneATRmult      = input.float(0.5, "Zone Height (ATR x)", step=0.1, tooltip="Zone thickness = ATR(14) * this")
atrLen           = input.int(14, "ATR Length", minval=1)
maxZones         = input.int(10, "Max Active Zones", minval=1, maxval=50)
wickRejPct       = input.float(0.4, "Wick Rejection % of Range", minval=0.0, maxval=1.0)
requireBodyRej   = input.bool(true, "Require Close Back Outside Zone")
riskR            = input.float(2.0, "Take Profit R Multiple", step=0.25)
slPadTicks       = input.int(2, "Stop Buffer (ticks)", minval=0)
tradeLongs       = input.bool(true,  "Enable Longs")
tradeShorts      = input.bool(true,  "Enable Shorts")
showLabels       = input.bool(true,  "Show Labels on Rejection")
showOnlyLast     = input.bool(false, "Show Only Most-Recent Zone of Each Type")
colorSupply      = color.new(color.red, 85)
colorDemand      = color.new(color.lime, 85)
borderSupply     = color.new(color.red, 0)
borderDemand     = color.new(color.green, 0)

//==================== HTF Series ====================//
[htfHigh, htfLow, htfClose, htfOpen, htfATR] = request.security(syminfo.tickerid, tfHTF, [high, low, close, open, ta.atr(atrLen)], barmerge.gaps_off, barmerge.lookahead_off)
ph  = request.security(syminfo.tickerid, tfHTF, ta.pivothigh(htfHigh, leftBars, rightBars))
pl  = request.security(syminfo.tickerid, tfHTF, ta.pivotlow(htfLow,   leftBars, rightBars))
newPH = not na(ph)
newPL = not na(pl)

// Zone height from HTF ATR
zH = math.max(syminfo.mintick, htfATR * zoneATRmult)

//==================== Storage for Zones ====================//
var supplyBoxes = array.new_box()
var demandBoxes = array.new_box()
var supplyTop   = array.new_float()
var supplyBot   = array.new_float()
var demandTop   = array.new_float()
var demandBot   = array.new_float()
var supplyAlive = array.new_bool()
var demandAlive = array.new_bool()

// Housekeeping: extend all boxes to current bar, cull invalid or excess
f_extend_and_cull(_boxes, _tops, _bots, _alive, _max, _isSupply) =>
    for i = array.size(_boxes) - 1 to 0
        bx   = array.get(_boxes, i)
        top  = array.get(_tops,  i)
        bot  = array.get(_bots,  i)
        live = array.get(_alive, i)
        if live
            box.set_right(bx, bar_index)
            // Invalidation: close outside in adverse direction
            if _isSupply and close > top
                array.set(_alive, i, false), box.delete(bx)
            if not _isSupply and close < bot
                array.set(_alive, i, false), box.delete(bx)
        // Remove dead ones from arrays
        if not array.get(_alive, i)
            array.remove(_boxes, i)
            array.remove(_tops,  i)
            array.remove(_bots,  i)
            array.remove(_alive, i)
    // Trim to max
    while array.size(_boxes) > _max
        // remove oldest (index 0)
        box.delete(array.get(_boxes, 0))
        array.remove(_boxes, 0)
        array.remove(_tops,  0)
        array.remove(_bots,  0)
        array.remove(_alive, 0)

//==================== Create New Zones on fresh HTF pivots ====================//
if newPH
    top = ph
    bot = ph - zH
    // Optional: show only most recent => nuke existing of this type
    if showOnlyLast
        for i = 0 to array.size(supplyBoxes)-1
            bx = array.get(supplyBoxes, i)
            box.delete(bx)
        array.clear(supplyBoxes), array.clear(supplyTop), array.clear(supplyBot), array.clear(supplyAlive)
    bx = box.new(left=bar_index, top=top, right=bar_index, bottom=bot, xloc=xloc.bar_index, bgcolor=colorSupply, border_color=borderSupply, extend=extend.right)
    array.push(supplyBoxes, bx)
    array.push(supplyTop,   top)
    array.push(supplyBot,   bot)
    array.push(supplyAlive, true)

if newPL
    top = pl + zH
    bot = pl
    if showOnlyLast
        for i = 0 to array.size(demandBoxes)-1
            bx = array.get(demandBoxes, i)
            box.delete(bx)
        array.clear(demandBoxes), array.clear(demandTop), array.clear(demandBot), array.clear(demandAlive)
    bx = box.new(left=bar_index, top=top, right=bar_index, bottom=bot, xloc=xloc.bar_index, bgcolor=colorDemand, border_color=borderDemand, extend=extend.right)
    array.push(demandBoxes, bx)
    array.push(demandTop,   top)
    array.push(demandBot,   bot)
    array.push(demandAlive, true)

// Update & prune
f_extend_and_cull(supplyBoxes, supplyTop, supplyBot, supplyAlive, maxZones, true)
f_extend_and_cull(demandBoxes, demandTop, demandBot, demandAlive, maxZones, false)

//==================== Touch & Rejection Logic ====================//
f_wickPct(_open, _high, _low, _close) =>
    rng = _high - _low
    upW = _high - math.max(_open, _close)
    dnW = math.min(_open, _close) - _low
    [rng, upW, dnW]

var bool  rejectionSupply = false
var bool  rejectionDemand = false
var float rejSupplyPrice  = na
var float rejDemandPrice  = na

// Check supply zones (top resistance band [bot..top])
for i = 0 to array.size(supplyBoxes) - 1
    top = array.get(supplyTop, i)
    bot = array.get(supplyBot, i)
    // Touched?
    touched = high >= bot and low <= top
    if touched
        [rng, upW, _] = f_wickPct(open, high, low, close)
        wickOK = rng > 0 ? (upW / rng) >= wickRejPct : false
        bodyRej = requireBodyRej ? close < bot : true
        bearCandle = close < open
        if (wickOK or bearCandle) and bodyRej
            rejectionSupply := true
            rejSupplyPrice  := bot

// Check demand zones ([bot..top])
for i = 0 to array.size(demandBoxes) - 1
    top = array.get(demandTop, i)
    bot = array.get(demandBot, i)
    touched = high >= bot and low <= top
    if touched
        [rng, _, dnW] = f_wickPct(open, high, low, close)
        wickOK = rng > 0 ? (dnW / rng) >= wickRejPct : false
        bodyRej = requireBodyRej ? close > top : true
        bullCandle = close > open
        if (wickOK or bullCandle) and bodyRej
            rejectionDemand := true
            rejDemandPrice  := top

//==================== Plotting labels ====================//
plotshape(rejectionSupply, title="Supply Rejection", style=shape.triangledown, color=color.red, size=size.tiny, location=location.abovebar, text="SUP ✖")
plotshape(rejectionDemand, title="Demand Rejection", style=shape.triangleup,   color=color.lime, size=size.tiny, location=location.belowbar, text="DEM ✔")

if showLabels and rejectionSupply
    label.new(bar_index, high, text="Supply Rejection\n" + str.tostring(tfHTF), style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white)
if showLabels and rejectionDemand
    label.new(bar_index, low, text="Demand Rejection\n" + str.tostring(tfHTF), style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white)

//==================== Alerts ====================//
alertcondition(rejectionSupply, title="SUPPLY Zone Rejection", message="Supply rejection on {{ticker}} {{interval}} (HTF set in inputs)")
alertcondition(rejectionDemand, title="DEMAND Zone Rejection", message="Demand rejection on {{ticker}} {{interval}} (HTF set in inputs)")


//==================== Strategy Entries & Risk ====================//
getTicks(_price, _ticks) =>
    _ticks * syminfo.mintick * (syminfo.type == "crypto" ? 1.0 : 1.0)  // neutral; left for broker-specific quirk if needed

// Short on supply rejection
// Short on supply rejection
if rejectionSupply and tradeShorts
    float sl = na // Reset inside the block
    // Stop just above top of nearest active supply zone
    for i = 0 to array.size(supplyTop) - 1
        top = array.get(supplyTop, i)
        bot = array.get(supplyBot, i)
        if high >= bot and low <= top
            sl := top + getTicks(top, slPadTicks)
            break
    sl := na(sl) ? high + getTicks(high, slPadTicks) : sl
    entryPrice = close
    risk = sl - entryPrice
    tp = entryPrice - riskR * risk
    strategy.entry("Short@Rej", strategy.short, comment="SupRej")
    strategy.exit("Short@Rej-Exit", from_entry="Short@Rej", stop=sl, limit=tp)

// Long on demand rejection
if rejectionDemand and tradeLongs
    float sl = na
    for i = 0 to array.size(demandTop) - 1
        top = array.get(demandTop, i)
        bot = array.get(demandBot, i)
        if high >= bot and low <= top
            sl := bot - getTicks(bot, slPadTicks)
            break
    sl := na(sl) ? low - getTicks(low, slPadTicks) : sl
    entryPrice = close
    risk = entryPrice - sl
    tp = entryPrice + riskR * risk
    strategy.entry("Long@Rej", strategy.long, comment="DemRej")
    strategy.exit("Long@Rej-Exit", from_entry="Long@Rej", stop=sl, limit=tp)

//==================== Info Panel ====================//
var table t = table.new(position.top_right, 1, 4, frame_color=color.new(color.gray, 70))
if barstate.islast
    table.cell(t, 0, 0, "HTF: " + str.tostring(tfHTF), text_color=color.white, bgcolor=color.new(color.blue, 70))
    table.cell(t, 0, 1, "Zones: S=" + str.tostring(array.size(supplyBoxes)) + " D=" + str.tostring(array.size(demandBoxes)), text_color=color.white, bgcolor=color.new(color.gray, 80))
    table.cell(t, 0, 2, "Last: " + (rejectionSupply ? "Supply Rej" : rejectionDemand ? "Demand Rej" : "—"), text_color=color.white, bgcolor=color.new(color.gray, 80))
    table.cell(t, 0, 3, "RR=" + str.tostring(riskR) + " | ATR*=" + str.tostring(zoneATRmult), text_color=color.white, bgcolor=color.new(color.gray, 80))
