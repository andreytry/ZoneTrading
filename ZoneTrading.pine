//@version=5 
indicator("Supply/Demand Zones (Wick-Based, Dynamic Extension)", overlay=true, max_boxes_count=500)

// === Constants ===
HISTORY_LENGTH = 500

// === Zones UI ===
group_zones = "Zones"
show_ct  = input.bool(true,  "Current Timeframe", group=group_zones)
show_5   = input.bool(true,  "M5",                group=group_zones, inline="ZSEL")
show_15  = input.bool(true,  "M15",               group=group_zones, inline="ZSEL")
show_60  = input.bool(true,  "M60",               group=group_zones, inline="ZSEL")

// === Timeframe Configuration ===
analysis_timeframe = input.timeframe(defval="60", title="Analysis Timeframe", tooltip="Timeframe to analyze for zones")

// === Inputs (UI Settings) ===
group_params = "Detection Settings"
initial_length   = input.int(100, "Initial Zone Length (bars)",            group=group_params)
days_back        = input.int(100, "Draw Zones For Last N Days",            group=group_params)
atr_length       = input.int(14,  "ATR Period",                            group=group_params)
long_atr_filter  = input.float(0.8, "Long Current Candle min body as % of ATR", step=0.01, group=group_params)
max_long_short_ratio = input.float(0.5, "Max Long/Short Ratio for small candles", step=0.01, group=group_params)
leg_out_leg_in_ratio = input.float(0.25, "Leg Out/Leg In Ratio", step=0.01, group=group_params)
breach_threshold = input.float(0.25, "Breach Threshold (% of zone height)", step=0.1, tooltip="How much price must penetrate zone to consider it breached", group=group_params)
max_small_candles = input.int(10, "Max Small Candles in Zone", minval=1, maxval=50, group=group_params)
max_wick_ratio = input.float(10, "Max wick length to body ratio", step=0.01, group=group_params)
max_zones = input.int(200, "Max Active Zones", minval=10, maxval=200, group=group_params)
// Distance filter multiplier (× Daily Range)
range_mult = input.float(2.5, "Zone distance filter (× Daily Range)", step=0.1, group=group_params)

// === TI-7: Rejection candle body threshold input (× ATR) ===
rejection_atr_mult = input.float(0.5, "Rejection Candle Min Body (× ATR)", minval=0.0, step=0.05, group=group_params)
// === TI-7: Alert toggle (default OFF) ===
alerts_on_departure = input.bool(false, "Alert on zone depature", group=group_params)

// === Helpers for MTF data ===
body_size_mtf(_open, _close) => math.abs(_close - _open)
is_green_mtf(_open, _close)  => _close > _open
is_red_mtf(_open, _close)    => _close < _open

// === Zone tracking type ===
type ZoneData
    box   zone_box
    float top
    float bottom
    string zone_type
    int   creation_bar_time
    string tf_label
    string label_text
    int   small_cnt
    int   legout_time  // TI-7

// === Arrays to store zone data ===
var array<ZoneData> active_zones = array.new<ZoneData>()

// === Historical data storage (60M) ===
var array<float> mtf_open_history_60  = array.new<float>()
var array<float> mtf_high_history_60  = array.new<float>()
var array<float> mtf_low_history_60   = array.new<float>()
var array<float> mtf_close_history_60 = array.new<float>()
var array<float> mtf_atr_history_60   = array.new<float>()
var array<int>   mtf_time_history_60  = array.new<int>()

// === Historical data storage (15M) ===
var array<float> mtf_open_history_15  = array.new<float>()
var array<float> mtf_high_history_15  = array.new<float>()
var array<float> mtf_low_history_15   = array.new<float>()
var array<float> mtf_close_history_15 = array.new<float>()
var array<float> mtf_atr_history_15   = array.new<float>()
var array<int>   mtf_time_history_15  = array.new<int>()

// === Historical data storage (5M) ===
var array<float> mtf_open_history_5  = array.new<float>()
var array<float> mtf_high_history_5  = array.new<float>()
var array<float> mtf_low_history_5   = array.new<float>()
var array<float> mtf_close_history_5 = array.new<float>()
var array<float> mtf_atr_history_5   = array.new<float>()
var array<int>   mtf_time_history_5  = array.new<int>()

// === Historical data storage (Current Timeframe) ===
var array<float> mtf_open_history_ct  = array.new<float>()
var array<float> mtf_high_history_ct  = array.new<float>()
var array<float> mtf_low_history_ct   = array.new<float>()
var array<float> mtf_close_history_ct = array.new<float>()
var array<float> mtf_atr_history_ct   = array.new<float>()
var array<int>   mtf_time_history_ct  = array.new<int>()

// === Daily range (computed OUTSIDE loops/conditionals) ===
[dHighD, dLowD] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_off)
daily_range = dHighD - dLowD

// Helper: current-range check (keeps same logic you had)
is_zone_in_range(_top, _bottom) =>
    float mid   = (_top + _bottom) * 0.5
    float denom = math.max(daily_range, syminfo.mintick)
    float norm  = math.abs(close - mid) / denom
    norm <= range_mult

// === Breach check ===
is_zone_breached(zone_data) =>
    float zone_height   = zone_data.top - zone_data.bottom
    float breach_amount = zone_height * breach_threshold
    zone_data.zone_type == "Supply" ? high > zone_data.top + breach_amount : low < zone_data.bottom - breach_amount

// === Universal boundaries function with array parameters ===
find_zone_boundaries_universal(start_idx, num_small_candles, zone_type, open_hist, high_hist, low_hist, close_hist) =>
    float zone_top = na
    float zone_bottom = na
    
    if zone_type == "Demand"
        zone_top   := math.max(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        zone_bottom:= array.get(low_hist,  start_idx)
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, math.max(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
                zone_bottom := math.min(zone_bottom, array.get(low_hist,  start_idx + i))
    else
        zone_top   := array.get(high_hist, start_idx)
        zone_bottom:= math.min(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, array.get(high_hist, start_idx + i))
                zone_bottom := math.min(zone_bottom, math.min(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
    [zone_top, zone_bottom]

// === TI-2: Overlap detection helper (same timeframe) ===
ti2_overlap(z1, z2) =>
    not (z1.bottom > z2.top or z2.bottom > z1.top)

// === Extend / cull + RANGE TOGGLING ===
update_zones() =>
    if array.size(active_zones) > 0
        int i = array.size(active_zones) - 1
        while i >= 0
            ZoneData z = array.get(active_zones, i)

            if is_zone_breached(z)
                if not na(z.zone_box)
                    box.delete(z.zone_box)
                array.remove(active_zones, i)
                i -= 1
                continue

            bool in_range_now = is_zone_in_range(z.top, z.bottom)

            if in_range_now and na(z.zone_box)
                color zone_color = z.zone_type == "Demand" ? color.orange : color.blue
                box bx = box.new(
                     z.creation_bar_time, z.top,
                     z.creation_bar_time, z.bottom,
                     xloc=xloc.bar_time, extend=extend.right,
                     border_color=zone_color, bgcolor=color.new(zone_color, 85),
                     text=z.label_text, text_color=zone_color, text_size=size.small)
                ZoneData z2 = ZoneData.new(bx, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt, z.legout_time)
                array.set(active_zones, i, z2)

            if (not in_range_now) and not na(z.zone_box)
                box.delete(z.zone_box)
                ZoneData z3 = ZoneData.new(na, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt, z.legout_time)
                array.set(active_zones, i, z3)

            i -= 1

// === TI-2: Overlap culling pass — keep earliest zone (earliest creation_bar_time) per timeframe ===
ti2_cull_overlaps_same_tf() =>
    int i = 0
    while i < array.size(active_zones)
        ZoneData zi = array.get(active_zones, i)
        int j = i + 1
        while j < array.size(active_zones)
            ZoneData zj = array.get(active_zones, j)
            if zi.tf_label == zj.tf_label and ti2_overlap(zi, zj)
                bool keep_i = zi.creation_bar_time <= zj.creation_bar_time
                int remove_index = keep_i ? j : i
                ZoneData zr = array.get(active_zones, remove_index)
                if not na(zr.zone_box)
                    box.delete(zr.zone_box)
                array.remove(active_zones, remove_index)
                if not keep_i
                    if i < array.size(active_zones)
                        zi := array.get(active_zones, i)
                    j := i + 1
                    continue
                continue
            else
                j += 1
        i += 1

// === Universal MTF Pattern Detection ===
detect_mtf_patterns_universal(tf, tf_label, open_hist, high_hist, low_hist, close_hist, atr_hist, time_hist) =>
    string actual_tf = tf == "" ? timeframe.period : tf
    [mtf_open, mtf_high, mtf_low, mtf_close, mtf_atr, htf_time] = request.security(syminfo.tickerid, actual_tf, [open, high, low, close, ta.atr(atr_length), time], lookahead=barmerge.lookahead_off)
    bool is_new_htf_bar = ta.change(time(actual_tf))
    if is_new_htf_bar and not na(mtf_open)
        array.unshift(open_hist,  mtf_open)
        array.unshift(high_hist,  mtf_high)
        array.unshift(low_hist,   mtf_low)
        array.unshift(close_hist, mtf_close)
        array.unshift(atr_hist,   mtf_atr)
        array.unshift(time_hist,  htf_time)

        if array.size(open_hist) > HISTORY_LENGTH
            array.pop(open_hist), array.pop(high_hist), array.pop(low_hist), array.pop(close_hist), array.pop(atr_hist), array.pop(time_hist)

        if array.size(open_hist) >= max_small_candles + 2
            float cur_open  = array.get(open_hist,  0)
            float cur_close = array.get(close_hist, 0)
            float cur_body  = body_size_mtf(cur_open, cur_close)
            float cur_atr   = array.get(atr_hist,  0)
            float min_long_body = cur_atr * long_atr_filter

            if cur_body >= min_long_body
                int   mark_time = array.get(time_hist, 0)
                float hi0       = array.get(high_hist, 0)
                float lo0       = array.get(low_hist, 0)

                string cur_color = is_green_mtf(cur_open, cur_close) ? "green" : is_red_mtf(cur_open, cur_close) ? "red" : "na"

                int small_count = 0
                int idx = 1
                bool valid_pattern = false
                int  leg_in_index = -1

                while idx <= max_small_candles and idx < array.size(open_hist)
                    float s_open  = array.get(open_hist,  idx)
                    float s_close = array.get(close_hist, idx)
                    float s_body  = body_size_mtf(s_open, s_close)

                    if small_count >= 1
                        float leg_open  = array.get(open_hist,  idx)
                        float leg_close = array.get(close_hist, idx)
                        float leg_body  = body_size_mtf(leg_open, leg_close)
                        if leg_body >= cur_body * leg_out_leg_in_ratio
                            valid_pattern := true
                            leg_in_index  := idx
                            break

                    float s_high  = array.get(high_hist, idx)
                    float s_low   = array.get(low_hist,  idx)
                    float up_w    = s_high - math.max(s_open, s_close)
                    float dn_w    = math.min(s_open, s_close) - s_low
                    float mx_w    = math.max(up_w, dn_w)

                    bool wick_ok  = (s_body > 0) and (mx_w <= s_body * max_wick_ratio)
                    bool size_ok  = (s_body <= cur_body * max_long_short_ratio)

                    if wick_ok and size_ok
                        small_count += 1
                        idx += 1
                        continue
                    else
                        break

                if not valid_pattern and small_count >= 1
                    int idx_candidate = math.min(idx, array.size(open_hist) - 1)
                    valid_pattern := true
                    leg_in_index  := idx_candidate

                if valid_pattern and leg_in_index > 0
                    float leg_open  = array.get(open_hist,  leg_in_index)
                    float leg_close = array.get(close_hist, leg_in_index)
                    string leg_color = is_green_mtf(leg_open, leg_close) ? "green" : is_red_mtf(leg_open, leg_close) ? "red" : "na"

                    string zone_type = na, string zone_title = na
                    if     cur_color == "green" and leg_color == "red"
                        zone_type := "Demand", zone_title := "drop-base-rally"
                    else if cur_color == "green" and leg_color == "green"
                        zone_type := "Demand", zone_title := "rally-base-rally"
                    else if cur_color == "red"   and leg_color == "green"
                        zone_type := "Supply", zone_title := "rally-base-drop"
                    else if cur_color == "red"   and leg_color == "red"
                        zone_type := "Supply", zone_title := "drop-base-drop"

                    if not na(zone_type)
                        [zone_top, zone_bottom] = find_zone_boundaries_universal(0, small_count, zone_type, open_hist, high_hist, low_hist, close_hist)
                        color  zone_color = zone_type == "Demand" ? color.orange : color.blue
                        string display_tf_label = actual_tf == timeframe.period ? "CT" : tf_label

                        int left_time = array.get(time_hist, small_count)
                        int legout_time0 = array.get(time_hist, 0) // TI-7

                        string label_txt = display_tf_label + ":" + zone_title + " (" + str.tostring(small_count) + ")"
                        bool   draw_now  = is_zone_in_range(zone_top, zone_bottom)

                        box bx = na
                        if draw_now
                            bx := box.new(left_time, zone_top, left_time, zone_bottom, xloc=xloc.bar_time, extend=extend.right,
                                          border_color=zone_color, bgcolor=color.new(zone_color, 85),
                                          text=label_txt, text_color=zone_color, text_size=size.small)

                        ZoneData new_zone = ZoneData.new(bx, zone_top, zone_bottom, zone_type, left_time, display_tf_label, label_txt, small_count, legout_time0)
                        array.unshift(active_zones, new_zone)

                        if array.size(active_zones) > max_zones
                            ZoneData oldest = array.pop(active_zones)
                            if not na(oldest.zone_box)
                                box.delete(oldest.zone_box)

                        ti2_cull_overlaps_same_tf()

// === TI-7: Rejection detection helpers and function ===
within_zone(val, top, bottom) =>
    val <= top and val >= bottom

// Detect rejections ONLY when price REVISITS the zone and then LEAVES it with a strong move (>= threshold).
// Do NOT mark if the bar closes inside the zone. Allow "just-touch" by min/max.
// TI-7: Trigger alerts and draw B/S only when alerts toggle is ON.
detect_rejections() =>
    if array.size(active_zones) > 0
        float atr_now = ta.atr(atr_length)
        float min_reject_body = atr_now * rejection_atr_mult
        float body = math.abs(close - open)
        bool green = close > open
        bool red   = close < open

        for i = 0 to array.size(active_zones) - 1
            ZoneData z = array.get(active_zones, i)

            // Skip the very legout bar that formed the zone
            bool after_legout = time > z.legout_time
            if not after_legout
                continue

            if z.zone_type == "Demand"
                bool touched = low <= z.top
                bool left_up = close > z.top
                bool strong  = green and (body >= min_reject_body)
                if alerts_on_departure and touched and left_up and strong  // TI-7
                    float level_d = z.top
                    label.new(bar_index, low, "B", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.tiny)  // TI-7
                    alert("Price of " + syminfo.ticker + " rejected from the level ..... " + str.tostring(level_d, format.mintick), alert.freq_once_per_bar_close) // TI-7

            if z.zone_type == "Supply"
                bool touched = high >= z.bottom
                bool left_dn = close < z.bottom
                bool strong  = red and (body >= min_reject_body)
                if alerts_on_departure and touched and left_dn and strong  // TI-7
                    float level_s = z.bottom
                    label.new(bar_index, high, "S", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.tiny) // TI-7
                    alert("Price of " + syminfo.ticker + " rejected from the level ..... " + str.tostring(level_s, format.mintick), alert.freq_once_per_bar_close) // TI-7

// === Main orchestration placed at the bottom ===
main() =>
    if show_60
        detect_mtf_patterns_universal("60", "60M", mtf_open_history_60, mtf_high_history_60, mtf_low_history_60, mtf_close_history_60, mtf_atr_history_60, mtf_time_history_60)
    if show_15
        detect_mtf_patterns_universal("15", "15M", mtf_open_history_15, mtf_high_history_15, mtf_low_history_15, mtf_close_history_15, mtf_atr_history_15, mtf_time_history_15)
    if show_5
        detect_mtf_patterns_universal("5", "5M", mtf_open_history_5, mtf_high_history_5, mtf_low_history_5, mtf_close_history_5, mtf_atr_history_5, mtf_time_history_5)
    if show_ct
        detect_mtf_patterns_universal("", "CT", mtf_open_history_ct, mtf_high_history_ct, mtf_low_history_ct, mtf_close_history_ct, mtf_atr_history_ct, mtf_time_history_ct)

    update_zones()
    detect_rejections() // TI-7

// === Run main ===
main()
