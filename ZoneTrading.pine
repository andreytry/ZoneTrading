//@version=5 
indicator("Supply/Demand Zones (Wick-Based, Dynamic Extension)", overlay=true, max_boxes_count=500)  

// === Inputs ===
initial_length   = input.int(100, "Initial Zone Length (bars)")
days_back        = input.int(100, "Draw Zones For Last N Days")
atr_length       = input.int(14, "ATR Period")
long_atr_filter  = input.float(0.5, "Long Current Candle min body as % of ATR", step=0.01)
max_long_short_ratio = input.float(0.5, "Max Long/Short Ratio for small candles", step=0.01)
leg_out_leg_in_ratio = input.float(0.25, "Leg Out/Leg In Ratio", step=0.01)
breach_threshold = input.float(0.8, "Breach Threshold (% of zone height)", step=0.1, tooltip="How much price must penetrate zone to consider it breached")
max_small_candles = input.int(10, "Max Small Candles in Zone", minval=1, maxval=50)

// === Helpers ===
body_size(idx) => math.abs(close[idx] - open[idx])
is_green(idx) => close[idx] > open[idx]
is_red(idx)   => close[idx] < open[idx]

// === ATR Calculation ===
atr_val = ta.atr(atr_length)

// === Time Filter ===
ms_in_day   = 24 * 60 * 60 * 1000
start_time  = timenow - days_back * ms_in_day
in_last_days = time >= start_time

// === Zone tracking type ===
type ZoneData
    box zone_box
    float top
    float bottom
    string zone_type
    int creation_bar

// === Arrays to store zone data ===
var array<ZoneData> active_zones = array.new<ZoneData>()

// === Function to check if zone is breached ===
is_zone_breached(zone_data) =>
    zone_height = zone_data.top - zone_data.bottom
    breach_amount = zone_height * breach_threshold
    
    if zone_data.zone_type == "Supply"
        // Supply zone breached when price closes significantly above the top
        close > zone_data.top + breach_amount
    else
        // Demand zone breached when price closes significantly below the bottom
        close < zone_data.bottom - breach_amount

// === Function to find zone boundaries using wick-based logic ===
find_zone_boundaries(start_idx, num_small_candles, zone_type) =>
    float zone_top = na
    float zone_bottom = na
    
    if zone_type == "Demand"
        // For demand zones: top = highest close of small candles, bottom = lowest low of small candles
        zone_top := math.max(open[start_idx + 1], close[start_idx + 1])
        zone_bottom := low[start_idx]
        
        for i = 1 to num_small_candles
            if start_idx + i < bar_index
                zone_top := math.max(zone_top, math.max(open[start_idx + i], close[start_idx + i]))
                zone_bottom := math.min(zone_bottom, low[start_idx + i])
    else
        // For supply zones: top = highest high of small candles, bottom = lowest close of small candles  
        zone_top := high[start_idx]
        zone_bottom := math.min(open[start_idx + 1], close[start_idx + 1])
        
        for i = 1 to num_small_candles 
            if start_idx + i < bar_index
                zone_top := math.max(zone_top, high[start_idx + i])
                zone_bottom := math.min(zone_bottom, math.min(open[start_idx + i], close[start_idx + i]))
    
    [zone_top, zone_bottom]

// === Function to update zone extensions ===
update_zones() =>
    if array.size(active_zones) > 0
        i = array.size(active_zones) - 1
        while i >= 0
            zone_data = array.get(active_zones, i)
            
            // Check if zone is breached
            if is_zone_breached(zone_data)
                // Remove breached zone
                box.delete(zone_data.zone_box)
                array.remove(active_zones, i)
            else
                // Extend the zone to current bar
                box.set_right(zone_data.zone_box, bar_index)
            i := i - 1

// === Main Pattern Detection Logic ===
if bar_index >= max_small_candles + 2 
    // Step 1: Check if current candle passes ATR filter
    float current_body = body_size(0)
    float min_long_body = atr_val * long_atr_filter
    
    if current_body >= min_long_body
        string cur_color = is_green(0) ? "green" : is_red(0) ? "red" : "na"
        
        // Step 2: Start iteration to the left checking up to max_small_candles
        int small_candle_count = 0
        int check_index = 1
        bool valid_pattern = false
        int leg_in_index = -1
        
        // Check each candle to the left
        while check_index <= max_small_candles 
            float check_body = body_size(check_index)
            
            // Check if candle is small (no more than current_body * max_long_short_ratio)
            if check_body <= current_body * max_long_short_ratio
                small_candle_count := small_candle_count + 1
                
                // Check wick filter - reject if any small candle has wick > 3x body
                if check_body > 0
                    upper_wick = high[check_index] - math.max(open[check_index], close[check_index])
                    lower_wick = math.min(open[check_index], close[check_index]) - low[check_index]
                    max_wick = math.max(upper_wick, lower_wick)
                    if max_wick > check_body * 20
                        break  // Exit if wick filter fails
                else
                    break  // Reject doji candles
                
                check_index := check_index + 1
            else
                // Found a larger candle - check if it qualifies as leg out
                if small_candle_count >= 1  // At least 2 small candles found
                    float leg_in_body = body_size(check_index)
                    if leg_in_body >= current_body * leg_out_leg_in_ratio
                        valid_pattern := true
                        leg_in_index := check_index
                break
        
        // Step 3: If valid pattern found, create the zone
        if valid_pattern and leg_in_index > 0
            string leg_in_color = is_green(leg_in_index) ? "green" : is_red(leg_in_index) ? "red" : "na"
            
            string zone_type = na
            color zone_color = na
            string zone_title = na
            
            // Determine zone type based on current and leg out candle colors
            if cur_color == "green" and leg_in_color == "red"
                zone_type := "Demand"
                zone_color := color.orange
                zone_title := "drop-base-rally"
            else if cur_color == "green" and leg_in_color == "green"
                zone_type := "Demand" 
                zone_color := color.orange
                zone_title := "rally-base-rally"
            else if cur_color == "red" and leg_in_color == "green"
                zone_type := "Supply"
                zone_color := color.blue
                zone_title := "rally-base-drop"
            else if cur_color == "red" and leg_in_color == "red"
                zone_type := "Supply"
                zone_color := color.blue
                zone_title := "drop-base-drop"
            
            if not na(zone_type)
                // Find zone boundaries using wick-based method
                [zone_top, zone_bottom] = find_zone_boundaries(0, small_candle_count, zone_type)
                
                // Create the zone box
                new_box = box.new(bar_index-small_candle_count, zone_top, bar_index-small_candle_count+initial_length, zone_bottom, border_color=zone_color, bgcolor=color.new(zone_color, 85), text=zone_title + " (" + str.tostring(small_candle_count) + ")", text_color=zone_color, text_size=size.small)
                
                // Create zone data and add to active zones
                new_zone = ZoneData.new(new_box, zone_top, zone_bottom, zone_type, bar_index-small_candle_count)
                
                array.unshift(active_zones, new_zone)

// === Update zones on every bar ===
update_zones()

// === Clean up old zones (optional - keeps performance good) ===
if array.size(active_zones) > 50
    oldest_zone = array.pop(active_zones)
    box.delete(oldest_zone.zone_box)