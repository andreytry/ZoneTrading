//@version=5 
// TI-5: switched to strategy() to allow order generation; kept title identical as requested.
strategy("Supply/Demand Zones (Wick-Based, Dynamic Extension)", overlay=true, max_boxes_count=500)

// === Constants ===
HISTORY_LENGTH = 500

// === Zones UI ===
group_zones = "Zones"
show_ct  = input.bool(true,  "Current Timeframe", group=group_zones)
show_5   = input.bool(true,  "M5",                group=group_zones, inline="ZSEL")
show_15  = input.bool(true,  "M15",               group=group_zones, inline="ZSEL")
show_60  = input.bool(true,  "M60",               group=group_zones, inline="ZSEL")

// === Timeframe Configuration ===
analysis_timeframe = input.timeframe(defval="60", title="Analysis Timeframe", tooltip="Timeframe to analyze for zones")

// === Inputs (UI Settings) ===
group_params = "Detection Settings"
initial_length   = input.int(100, "Initial Zone Length (bars)",            group=group_params)
days_back        = input.int(100, "Draw Zones For Last N Days",            group=group_params)
atr_length       = input.int(14,  "ATR Period",                            group=group_params)
long_atr_filter  = input.float(0.8, "Long Current Candle min body as % of ATR", step=0.01, group=group_params)
max_long_short_ratio = input.float(0.5, "Max Long/Short Ratio for small candles", step=0.01, group=group_params)
leg_out_leg_in_ratio = input.float(0.25, "Leg Out/Leg In Ratio", step=0.01, group=group_params)
breach_threshold = input.float(0.25, "Breach Threshold (% of zone height)", step=0.1, tooltip="How much price must penetrate zone to consider it breached", group=group_params)
max_small_candles = input.int(10, "Max Small Candles in Zone", minval=1, maxval=50, group=group_params)
max_wick_ratio = input.float(10, "Max wick length to body ratio", step=0.01, group=group_params)
max_zones = input.int(200, "Max Active Zones", minval=10, maxval=200, group=group_params)
// Distance filter multiplier (× Daily Range)
range_mult = input.float(2.5, "Zone distance filter (× Daily Range)", step=0.1, group=group_params)

// === Helpers for MTF data ===
body_size_mtf(_open, _close) => math.abs(_close - _open)
is_green_mtf(_open, _close)  => _close > _open
is_red_mtf(_open, _close)    => _close < _open

// === Zone tracking type ===
type ZoneData
    box   zone_box
    float top
    float bottom
    string zone_type
    int   creation_bar_time
    string tf_label
    string label_text
    int   small_cnt

// === Arrays to store zone data ===
var array<ZoneData> active_zones = array.new<ZoneData>()

// === Historical data storage (60M) ===
var array<float> mtf_open_history_60  = array.new<float>()
var array<float> mtf_high_history_60  = array.new<float>()
var array<float> mtf_low_history_60   = array.new<float>()
var array<float> mtf_close_history_60 = array.new<float>()
var array<float> mtf_atr_history_60   = array.new<float>()
var array<int>   mtf_time_history_60  = array.new<int>()

// === Historical data storage (15M) ===
var array<float> mtf_open_history_15  = array.new<float>()
var array<float> mtf_high_history_15  = array.new<float>()
var array<float> mtf_low_history_15   = array.new<float>()
var array<float> mtf_close_history_15 = array.new<float>()
var array<float> mtf_atr_history_15   = array.new<float>()
var array<int>   mtf_time_history_15  = array.new<int>()

// === Historical data storage (5M) ===
var array<float> mtf_open_history_5  = array.new<float>()
var array<float> mtf_high_history_5  = array.new<float>()
var array<float> mtf_low_history_5   = array.new<float>()
var array<float> mtf_close_history_5 = array.new<float>()
var array<float> mtf_atr_history_5   = array.new<float>()
var array<int>   mtf_time_history_5  = array.new<int>()

// === Historical data storage (Current Timeframe) ===
var array<float> mtf_open_history_ct  = array.new<float>()
var array<float> mtf_high_history_ct  = array.new<float>()
var array<float> mtf_low_history_ct   = array.new<float>()
var array<float> mtf_close_history_ct = array.new<float>()
var array<float> mtf_atr_history_ct   = array.new<float>()
var array<int>   mtf_time_history_ct  = array.new<int>()

// === Daily range (computed OUTSIDE loops/conditionals) ===
[dHighD, dLowD] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_off)
daily_range = dHighD - dLowD

// Helper: current-range check (keeps same logic you had)
is_zone_in_range(_top, _bottom) =>
    float mid   = (_top + _bottom) * 0.5
    float denom = math.max(daily_range, syminfo.mintick)
    float norm  = math.abs(close - mid) / denom
    norm <= range_mult

// === Breach check ===
is_zone_breached(zone_data) =>
    float zone_height   = zone_data.top - zone_data.bottom
    float breach_amount = zone_height * breach_threshold
    zone_data.zone_type == "Supply" ? high > zone_data.top + breach_amount : low < zone_data.bottom - breach_amount

// === Universal boundaries function with array parameters ===
find_zone_boundaries_universal(start_idx, num_small_candles, zone_type, open_hist, high_hist, low_hist, close_hist) =>
    float zone_top = na
    float zone_bottom = na
    
    if zone_type == "Demand"
        zone_top   := math.max(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        zone_bottom:= array.get(low_hist,  start_idx)
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, math.max(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
                zone_bottom := math.min(zone_bottom, array.get(low_hist,  start_idx + i))
    else
        zone_top   := array.get(high_hist, start_idx)
        zone_bottom:= math.min(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, array.get(high_hist, start_idx + i))
                zone_bottom := math.min(zone_bottom, math.min(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
    [zone_top, zone_bottom]

// === TI-2: Overlap detection helper (same timeframe) ===
ti2_overlap(z1, z2) =>
    // Overlap if price intervals intersect
    not (z1.bottom > z2.top or z2.bottom > z1.top)

// === Extend / cull + RANGE TOGGLING ===
update_zones() =>
    if array.size(active_zones) > 0
        int i = array.size(active_zones) - 1
        while i >= 0
            ZoneData z = array.get(active_zones, i)

            // 1) Hard breach => remove zone entirely
            if is_zone_breached(z)
                if not na(z.zone_box)
                    box.delete(z.zone_box)
                array.remove(active_zones, i)
                i -= 1
                continue

            // 2) Toggle visibility by current range
            bool in_range_now = is_zone_in_range(z.top, z.bottom)

            // If back in range and no box drawn -> (re)create it
            if in_range_now and na(z.zone_box)
                color zone_color = z.zone_type == "Demand" ? color.orange : color.blue
                box bx = box.new(
                     z.creation_bar_time, z.top,
                     z.creation_bar_time, z.bottom,
                     xloc=xloc.bar_time, extend=extend.right,
                     border_color=zone_color, bgcolor=color.new(zone_color, 85),
                     text=z.label_text, text_color=zone_color, text_size=size.small)
                // write back updated struct with new box handle
                ZoneData z2 = ZoneData.new(bx, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt)
                array.set(active_zones, i, z2)

            // If out of range and box exists -> delete box (keep zone)
            if (not in_range_now) and not na(z.zone_box)
                box.delete(z.zone_box)
                ZoneData z3 = ZoneData.new(na, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt)
                array.set(active_zones, i, z3)

            // === TI-5: Orders & alert when price ARRIVES to a zone that is NESTED inside another zone of the SAME TYPE ===
            // ARRIVES definition:
            //   Demand: candle HIGH outside (above top) AND LOW inside [bottom, top]
            //   Supply: candle LOW outside (below bottom) AND HIGH inside [bottom, top]
            bool low_in_zone  = low  <= z.top and low  >= z.bottom
            bool high_in_zone = high <= z.top and high >= z.bottom
            bool demand_arrives = z.zone_type == "Demand" and (high > z.top) and low_in_zone
            bool supply_arrives = z.zone_type == "Supply" and (low  < z.bottom) and high_in_zone
            bool arrived = demand_arrives or supply_arrives

            if arrived
                // Check nesting: z fully contained within another zone of same type
                bool nested_same_type = false
                int  j = 0
                while j < array.size(active_zones)
                    if j != i
                        ZoneData o = array.get(active_zones, j)
                        if o.zone_type == z.zone_type
                            if z.bottom >= o.bottom and z.top <= o.top
                                nested_same_type := true
                                break
                    j += 1

                if nested_same_type
                    float h   = z.top - z.bottom
                    float buf = h * 0.30  // 30% of zone height
                    float entry = close
                    if z.zone_type == "Demand"
                        float stop = z.bottom - buf
                        float risk = entry - stop
                        if risk > syminfo.mintick
                            float tp = entry + 2.0 * risk
                            string id = "TI5_LONG_" + str.tostring(z.creation_bar_time)
                            strategy.entry(id, strategy.long)
                            strategy.exit(id + "_EXIT", from_entry=id, stop=stop, limit=tp)
                            alert("Price entered a nested supply/demand zone", alert.freq_once_per_bar_close)
                    else
                        float stop = z.top + buf
                        float risk = stop - entry
                        if risk > syminfo.mintick
                            float tp = entry - 2.0 * risk
                            string id = "TI5_SHORT_" + str.tostring(z.creation_bar_time)
                            strategy.entry(id, strategy.short)
                            strategy.exit(id + "_EXIT", from_entry=id, stop=stop, limit=tp)
                            alert("Price entered a nested supply/demand zone", alert.freq_once_per_bar_close)
            // === END TI-5 ===

            i -= 1

// === TI-2: Overlap culling pass — keep earliest zone (earliest creation_bar_time) per timeframe ===
ti2_cull_overlaps_same_tf() =>
    int i = 0
    while i < array.size(active_zones)
        ZoneData zi = array.get(active_zones, i)
        int j = i + 1
        while j < array.size(active_zones)
            ZoneData zj = array.get(active_zones, j)
            if zi.tf_label == zj.tf_label and ti2_overlap(zi, zj)
                // keep the earliest (smaller creation_bar_time); remove the newer
                bool keep_i = zi.creation_bar_time <= zj.creation_bar_time
                int remove_index = keep_i ? j : i
                ZoneData zr = array.get(active_zones, remove_index)
                if not na(zr.zone_box)
                    box.delete(zr.zone_box)
                array.remove(active_zones, remove_index)
                // if we removed i, refresh zi and reset j
                if not keep_i
                    if i < array.size(active_zones)
                        zi := array.get(active_zones, i)
                    j := i + 1
                    continue
                // removed j; continue comparing zi with the new element at j
                continue
            else
                j += 1
        i += 1

// === Universal MTF Pattern Detection ===
detect_mtf_patterns_universal(tf, tf_label, open_hist, high_hist, low_hist, close_hist, atr_hist, time_hist) =>
    string actual_tf = tf == "" ? timeframe.period : tf

    // Pull HTF series (one value per HTF bar)
    [mtf_open, mtf_high, mtf_low, mtf_close, mtf_atr, htf_time] = request.security(syminfo.tickerid, actual_tf, [open, high, low, close, ta.atr(atr_length), time], lookahead=barmerge.lookahead_off)

    // Push only on NEW HTF bars (prevents intraday duplication)
    bool is_new_htf_bar = ta.change(time(actual_tf))
    if is_new_htf_bar and not na(mtf_open)
        array.unshift(open_hist,  mtf_open)
        array.unshift(high_hist,  mtf_high)
        array.unshift(low_hist,   mtf_low)
        array.unshift(close_hist, mtf_close)
        array.unshift(atr_hist,   mtf_atr)
        array.unshift(time_hist,  htf_time)

        if array.size(open_hist) > HISTORY_LENGTH
            array.pop(open_hist), array.pop(high_hist), array.pop(low_hist), array.pop(close_hist), array.pop(atr_hist), array.pop(time_hist)

        // Pattern detection (on distinct HTF bars)
        if array.size(open_hist) >= max_small_candles + 2
            float cur_open  = array.get(open_hist,  0)
            float cur_close = array.get(close_hist, 0)
            float cur_body  = body_size_mtf(cur_open, cur_close)
            float cur_atr   = array.get(atr_hist,  0)
            float min_long_body = cur_atr * long_atr_filter

            //Check if this is a strong LEGOUT
            if cur_body >= min_long_body

                // Found a LEGOUT mark with circle (kept commented per base)
                int   mark_time = array.get(time_hist, 0)
                float pad       = cur_atr * 0.05
                float hi0       = array.get(high_hist, 0)
                float lo0       = array.get(low_hist, 0)
                //if cur_close > cur_open
                //    label.new(mark_time, lo0 - pad, xloc=xloc.bar_time, style=label.style_circle, size=size.tiny, color=color.green, text="")
                //else if cur_close < cur_open
                //    label.new(mark_time, hi0 + pad, xloc=xloc.bar_time, style=label.style_circle, size=size.tiny, color=color.red, text="")

                string cur_color = is_green_mtf(cur_open, cur_close) ? "green" : is_red_mtf(cur_open, cur_close) ? "red" : "na"

                int small_count = 0
                int idx = 1
                bool valid_pattern = false
                int  leg_in_index = -1

                // LOOP (leg-in check first, then small validation; no fallback)
                while idx <= max_small_candles and idx < array.size(open_hist)
                    float s_open  = array.get(open_hist,  idx)
                    float s_close = array.get(close_hist, idx)
                    float s_body  = body_size_mtf(s_open, s_close)

                    // If we already have at least one valid small, check for big leg-in first
                    if small_count >= 1
                        float leg_open  = array.get(open_hist,  idx)
                        float leg_close = array.get(close_hist, idx)
                        float leg_body  = body_size_mtf(leg_open, leg_close)
                        if leg_body >= cur_body * leg_out_leg_in_ratio
                            valid_pattern := true
                            leg_in_index  := idx
                            break

                    // If no leg-in, validate current candle as a "small"
                    float s_high  = array.get(high_hist, idx)
                    float s_low   = array.get(low_hist,  idx)
                    float up_w    = s_high - math.max(s_open, s_close)
                    float dn_w    = math.min(s_open, s_close) - s_low
                    float mx_w    = math.max(up_w, dn_w)

                    bool wick_ok  = (s_body > 0) and (mx_w <= s_body * max_wick_ratio)
                    bool size_ok  = (s_body <= cur_body * max_long_short_ratio)

                    if wick_ok and size_ok
                        small_count += 1
                        idx += 1
                        continue
                    else
                        // Invalid small -> stop searching (no fallback leg-in)
                        break

                // If ALL small candles checked were valid, accept the zone and mark it
                if not valid_pattern and small_count >= 1
                    int idx_candidate = math.min(idx, array.size(open_hist) - 1)
                    valid_pattern := true
                    leg_in_index  := idx_candidate

                if valid_pattern and leg_in_index > 0
                    float leg_open  = array.get(open_hist,  leg_in_index)
                    float leg_close = array.get(close_hist, leg_in_index)
                    string leg_color = is_green_mtf(leg_open, leg_close) ? "green" : is_red_mtf(leg_open, leg_close) ? "red" : "na"

                    string zone_type = na, string zone_title = na
                    if     cur_color == "green" and leg_color == "red"   // drop-base-rally
                        zone_type := "Demand", zone_title := "drop-base-rally"
                    else if cur_color == "green" and leg_color == "green" // rally-base-rally
                        zone_type := "Demand", zone_title := "rally-base-rally"
                    else if cur_color == "red"   and leg_color == "green" // rally-base-drop
                        zone_type := "Supply", zone_title := "rally-base-drop"
                    else if cur_color == "red"   and leg_color == "red"   // drop-base-drop
                        zone_type := "Supply", zone_title := "drop-base-drop"

                    if not na(zone_type)
                        [zone_top, zone_bottom] = find_zone_boundaries_universal(0, small_count, zone_type, open_hist, high_hist, low_hist, close_hist)

                        color  zone_color = zone_type == "Demand" ? color.orange : color.blue
                        string display_tf_label = actual_tf == timeframe.period ? "CT" : tf_label

                        // Anchor by HTF time
                        int left_time = array.get(time_hist, small_count)

                        // Store zone ALWAYS; draw box now only if within range
                        string label_txt = display_tf_label + ":" + zone_title + " (" + str.tostring(small_count) + ")"
                        bool   draw_now  = is_zone_in_range(zone_top, zone_bottom)

                        box bx = na
                        if draw_now
                            bx := box.new(left_time, zone_top, left_time, zone_bottom, xloc=xloc.bar_time, extend=extend.right,
                                          border_color=zone_color, bgcolor=color.new(zone_color, 85),
                                          text=label_txt, text_color=zone_color, text_size=size.small)

                        ZoneData new_zone = ZoneData.new(bx, zone_top, zone_bottom, zone_type, left_time, display_tf_label, label_txt, small_count)
                        array.unshift(active_zones, new_zone)

                        if array.size(active_zones) > max_zones
                            ZoneData oldest = array.pop(active_zones)
                            if not na(oldest.zone_box)
                                box.delete(oldest.zone_box)

                        // === TI-2: After adding a zone, cull overlaps (same timeframe -> keep earliest) ===
                        ti2_cull_overlaps_same_tf()

// === Main ===
if show_60
    detect_mtf_patterns_universal("60", "60M", mtf_open_history_60, mtf_high_history_60, mtf_low_history_60, mtf_close_history_60, mtf_atr_history_60, mtf_time_history_60)  // 60M analysis
if show_15
    detect_mtf_patterns_universal("15", "15M", mtf_open_history_15, mtf_high_history_15, mtf_low_history_15, mtf_close_history_15, mtf_atr_history_15, mtf_time_history_15)  // 15M analysis
if show_5
    detect_mtf_patterns_universal("5", "5M", mtf_open_history_5, mtf_high_history_5, mtf_low_history_5, mtf_close_history_5, mtf_atr_history_5, mtf_time_history_5)    // 5M analysis
if show_ct
    detect_mtf_patterns_universal("", "CT", mtf_open_history_ct, mtf_high_history_ct, mtf_low_history_ct, mtf_close_history_ct, mtf_atr_history_ct, mtf_time_history_ct)  // Current timeframe analysis

update_zones()
