//@version=5
// TI-9: switch to strategy to place orders (keeps the same script title)
strategy("Supply/Demand Zones with Zone Arrival/Departure Alerts", overlay=true, max_boxes_count=500, pyramiding=0)

// === Constants ===
HISTORY_LENGTH = 500

// === Zones UI ===
group_zones = "Zones"
show_ct  = input.bool(true,  "Current Timeframe", group=group_zones)
show_5   = input.bool(true,  "M5",                group=group_zones, inline="ZSEL")
show_15  = input.bool(true,  "M15",               group=group_zones, inline="ZSEL")
show_60  = input.bool(true,  "M60",               group=group_zones, inline="ZSEL")

// === Timeframe Configuration ===
analysis_timeframe = input.timeframe(defval="60", title="Analysis Timeframe", tooltip="Timeframe to analyze for zones")

// === Inputs (UI Settings) ===
group_params = "Detection Settings"
initial_length   = input.int(100, "Initial Zone Length (bars)",            group=group_params)
days_back        = input.int(100, "Draw Zones For Last N Days",            group=group_params)
atr_length       = input.int(14,  "ATR Period",                            group=group_params)
long_atr_filter  = input.float(0.8, "Long Current Candle min body as % of ATR", step=0.01, group=group_params)
max_long_short_ratio = input.float(0.5, "Max Long/Short Ratio for small candles", step=0.01, group=group_params)
leg_out_leg_in_ratio = input.float(0.25, "Leg Out/Leg In Ratio", step=0.01, group=group_params)
breach_threshold = input.float(0.25, "Breach Threshold (% of zone height)", step=0.1, tooltip="How much price must penetrate zone to consider it breached", group=group_params)
max_small_candles = input.int(10, "Max Small Candles in Zone", minval=1, maxval=50, group=group_params)
max_wick_ratio = input.float(10, "Max wick length to body ratio", step=0.01, group=group_params)
max_zones = input.int(200, "Max Active Zones", minval=10, maxval=200, group=group_params)
// Distance filter multiplier (× Daily Range)
range_mult = input.float(2.5, "Zone distance filter (× Daily Range)", step=0.1, group=group_params)

// === TI-7: Rejection candle body threshold input (× ATR) ===
rejection_atr_mult = input.float(0.5, "Rejection Candle Min Body (× ATR)", minval=0.0, step=0.05, group=group_params)
// === TI-7: Alert toggle (default OFF) ===
alerts_on_departure = input.bool(false, "Alert on zone depature", group=group_params)

// === TI-9: Stop loss distance as % of zone height (outside the zone) ===
sl_zone_pct = input.float(0.30, "Stoploss distance percent of zone size", minval=0.0, step=0.01, group=group_params) // TI-9

// === TI-3: EMA settings & values (EMA50/EMA100 by default) ===
ema_fast_len = input.int(50, "EMA_FAST Length", minval=1, group=group_params) // TI-3
ema_slow_len = input.int(100, "EMA_SLOW Length", minval=1, group=group_params) // TI-3
ema_fast_val = ta.ema(close, ema_fast_len) // TI-3
ema_slow_val = ta.ema(close, ema_slow_len) // TI-3

// === Helpers for MTF data ===
body_size_mtf(_open, _close) => math.abs(_close - _open)
is_green_mtf(_open, _close)  => _close > _open
is_red_mtf(_open, _close)    => _close < _open

// === Zone tracking type ===
type ZoneData
    box   zone_box
    float top
    float bottom
    string zone_type
    int   creation_bar_time
    string tf_label
    string label_text
    int   small_cnt
    int   legout_time  // TI-7

// === Arrays to store zone data ===
var array<ZoneData> active_zones = array.new<ZoneData>()

// === Historical data storage (60M) ===
var array<float> mtf_open_history_60  = array.new<float>()
var array<float> mtf_high_history_60  = array.new<float>()
var array<float> mtf_low_history_60   = array.new<float>()
var array<float> mtf_close_history_60 = array.new<float>()
var array<float> mtf_atr_history_60   = array.new<float>()
var array<int>   mtf_time_history_60  = array.new<int>()

// === Historical data storage (15M) ===
var array<float> mtf_open_history_15  = array.new<float>()
var array<float> mtf_high_history_15  = array.new<float>()
var array<float> mtf_low_history_15   = array.new<float>()
var array<float> mtf_close_history_15 = array.new<float>()
var array<float> mtf_atr_history_15   = array.new<float>()
var array<int>   mtf_time_history_15  = array.new<int>()

// === Historical data storage (5M) ===
var array<float> mtf_open_history_5  = array.new<float>()
var array<float> mtf_high_history_5  = array.new<float>()
var array<float> mtf_low_history_5   = array.new<float>()
var array<float> mtf_close_history_5 = array.new<float>()
var array<float> mtf_atr_history_5   = array.new<float>()
var array<int>   mtf_time_history_5  = array.new<int>()

// === Historical data storage (Current Timeframe) ===
var array<float> mtf_open_history_ct  = array.new<float>()
var array<float> mtf_high_history_ct  = array.new<float>()
var array<float> mtf_low_history_ct   = array.new<float>()
var array<float> mtf_close_history_ct = array.new<float>()
var array<float> mtf_atr_history_ct   = array.new<float>()
var array<int>   mtf_time_history_ct  = array.new<int>()

// === Daily range (computed OUTSIDE loops/conditionals) ===
[dHighD, dLowD] = request.security(syminfo.tickerid, "D", [high, low], lookahead=barmerge.lookahead_off)
daily_range = dHighD - dLowD

// Helper: current-range check (keeps same logic you had)
is_zone_in_range(_top, _bottom) =>
    float mid   = (_top + _bottom) * 0.5
    float denom = math.max(daily_range, syminfo.mintick)
    float norm  = math.abs(close - mid) / denom
    norm <= range_mult

// === Breach check ===
is_zone_breached(zone_data) =>
    float zone_height   = zone_data.top - zone_data.bottom
    float breach_amount = zone_height * breach_threshold
    zone_data.zone_type == "Supply" ? high > zone_data.top + breach_amount : low < zone_data.bottom - breach_amount

// === Universal boundaries function with array parameters ===
find_zone_boundaries_universal(start_idx, num_small_candles, zone_type, open_hist, high_hist, low_hist, close_hist) =>
    float zone_top = na
    float zone_bottom = na
    
    if zone_type == "Demand"
        zone_top   := math.max(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        zone_bottom:= array.get(low_hist,  start_idx)
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, math.max(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
                zone_bottom := math.min(zone_bottom, array.get(low_hist,  start_idx + i))
    else
        zone_top   := array.get(high_hist, start_idx)
        zone_bottom:= math.min(array.get(open_hist, start_idx + 1), array.get(close_hist, start_idx + 1))
        for i = 1 to num_small_candles
            if start_idx + i < array.size(open_hist)
                zone_top    := math.max(zone_top, array.get(high_hist, start_idx + i))
                zone_bottom := math.min(zone_bottom, math.min(array.get(open_hist, start_idx + i), array.get(close_hist, start_idx + i)))
    [zone_top, zone_bottom]

// === TI-2: Overlap detection helper (same timeframe) ===
ti2_overlap(z1, z2) =>
    not (z1.bottom > z2.top or z2.bottom > z1.top)

// === Extend / cull + RANGE TOGGLING ===
update_zones() =>
    if array.size(active_zones) > 0
        int i = array.size(active_zones) - 1
        while i >= 0
            ZoneData z = array.get(active_zones, i)

            if is_zone_breached(z)
                if not na(z.zone_box)
                    box.delete(z.zone_box)
                array.remove(active_zones, i)
                i -= 1
                continue

            bool in_range_now = is_zone_in_range(z.top, z.bottom)

            if in_range_now and na(z.zone_box)
                // TI-7: Change zone colors — Demand = green, Supply = red
                color zone_color = z.zone_type == "Demand" ? color.green : color.red
                box bx = box.new(z.creation_bar_time, z.top, z.creation_bar_time, z.bottom, xloc=xloc.bar_time, extend=extend.right, border_color=zone_color, bgcolor=color.new(zone_color, 85), text=z.label_text, text_color=zone_color, text_size=size.small)
                ZoneData z2 = ZoneData.new(bx, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt, z.legout_time)
                array.set(active_zones, i, z2)

            if (not in_range_now) and not na(z.zone_box)
                box.delete(z.zone_box)
                ZoneData z3 = ZoneData.new(na, z.top, z.bottom, z.zone_type, z.creation_bar_time, z.tf_label, z.label_text, z.small_cnt, z.legout_time)
                array.set(active_zones, i, z3)

            i -= 1

// === TI-2: Overlap culling pass — keep earliest zone (earliest creation_bar_time) per timeframe ===
ti2_cull_overlaps_same_tf() =>
    int i = 0
    while i < array.size(active_zones)
        ZoneData zi = array.get(active_zones, i)
        int j = i + 1
        while j < array.size(active_zones)
            ZoneData zj = array.get(active_zones, j)
            if zi.tf_label == zj.tf_label and ti2_overlap(zi, zj)
                bool keep_i = zi.creation_bar_time <= zj.creation_bar_time
                int remove_index = keep_i ? j : i
                ZoneData zr = array.get(active_zones, remove_index)
                if not na(zr.zone_box)
                    box.delete(zr.zone_box)
                array.remove(active_zones, remove_index)
                if not keep_i
                    if i < array.size(active_zones)
                        zi := array.get(active_zones, i)
                    j := i + 1
                    continue
                continue
            else
                j += 1
        i += 1

// === Universal MTF Pattern Detection ===
detect_mtf_patterns_universal(tf, tf_label, open_hist, high_hist, low_hist, close_hist, atr_hist, time_hist) =>
    string actual_tf = tf == "" ? timeframe.period : tf
    [mtf_open, mtf_high, mtf_low, mtf_close, mtf_atr, htf_time] = request.security(syminfo.tickerid, actual_tf, [open, high, low, close, ta.atr(atr_length), time], lookahead=barmerge.lookahead_off)
    bool is_new_htf_bar = ta.change(time(actual_tf))
    if is_new_htf_bar and not na(mtf_open)
        array.unshift(open_hist,  mtf_open)
        array.unshift(high_hist,  mtf_high)
        array.unshift(low_hist,   mtf_low)
        array.unshift(close_hist, mtf_close)
        array.unshift(atr_hist,   mtf_atr)
        array.unshift(time_hist,  htf_time)

        if array.size(open_hist) > HISTORY_LENGTH
            array.pop(open_hist), array.pop(high_hist), array.pop(low_hist), array.pop(close_hist), array.pop(atr_hist), array.pop(time_hist)

        if array.size(open_hist) >= max_small_candles + 2
            float cur_open  = array.get(open_hist,  0)
            float cur_close = array.get(close_hist, 0)
            float cur_body  = body_size_mtf(cur_open, cur_close)
            float cur_atr   = array.get(atr_hist,  0)
            float min_long_body = cur_atr * long_atr_filter

            if cur_body >= min_long_body
                int   mark_time = array.get(time_hist, 0)
                float hi0       = array.get(high_hist, 0)
                float lo0       = array.get(low_hist, 0)

                string cur_color = is_green_mtf(cur_open, cur_close) ? "green" : is_red_mtf(cur_open, cur_close) ? "red" : "na"

                int small_count = 0
                int idx = 1
                bool valid_pattern = false
                int  leg_in_index = -1

                while idx <= max_small_candles and idx < array.size(open_hist)
                    float s_open  = array.get(open_hist,  idx)
                    float s_close = array.get(close_hist, idx)
                    float s_body  = body_size_mtf(s_open, s_close)

                    if small_count >= 1
                        float leg_open  = array.get(open_hist,  idx)
                        float leg_close = array.get(close_hist, idx)
                        float leg_body  = body_size_mtf(leg_open, leg_close)
                        if leg_body >= cur_body * leg_out_leg_in_ratio
                            valid_pattern := true
                            leg_in_index  := idx
                            break

                    float s_high  = array.get(high_hist, idx)
                    float s_low   = array.get(low_hist,  idx)
                    float up_w    = s_high - math.max(s_open, s_close)
                    float dn_w    = math.min(s_open, s_close) - s_low
                    float mx_w    = math.max(up_w, dn_w)

                    bool wick_ok  = (s_body > 0) and (mx_w <= s_body * max_wick_ratio)
                    bool size_ok  = (s_body <= cur_body * max_long_short_ratio)

                    if wick_ok and size_ok
                        small_count += 1
                        idx += 1
                    else
                        break

                if not valid_pattern and small_count >= 1
                    int idx_candidate = math.min(idx, array.size(open_hist) - 1)
                    valid_pattern := true
                    leg_in_index  := idx_candidate

                if valid_pattern and leg_in_index > 0
                    float leg_open  = array.get(open_hist,  leg_in_index)
                    float leg_close = array.get(close_hist, leg_in_index)
                    string leg_color = is_green_mtf(leg_open, leg_close) ? "green" : is_red_mtf(leg_open, leg_close) ? "red" : "na"

                    string zone_type = na, string zone_title = na
                    if     cur_color == "green" and leg_color == "red"
                        zone_type := "Demand", zone_title := "drop-base-rally"
                    else if cur_color == "green" and leg_color == "green"
                        zone_type := "Demand", zone_title := "rally-base-rally"
                    else if cur_color == "red"   and leg_color == "green"
                        zone_type := "Supply", zone_title := "rally-base-drop"
                    else if cur_color == "red"   and leg_color == "red"
                        zone_type := "Supply", zone_title := "drop-base-drop"

                    if not na(zone_type)
                        [zone_top, zone_bottom] = find_zone_boundaries_universal(0, small_count, zone_type, open_hist, high_hist, low_hist, close_hist)
                        // TI-7: Change zone colors — Demand = green, Supply = red
                        color  zone_color = zone_type == "Demand" ? color.green : color.red
                        string display_tf_label = actual_tf == timeframe.period ? "CT" : tf_label

                        int left_time = array.get(time_hist, small_count)
                        int legout_time0 = array.get(time_hist, 0) // TI-7

                        string label_txt = display_tf_label + ":" + zone_title + " (" + str.tostring(small_count) + ")"
                        bool   draw_now  = is_zone_in_range(zone_top, zone_bottom)

                        box bx = na
                        if draw_now
                            bx := box.new(left_time, zone_top, left_time, zone_bottom, xloc=xloc.bar_time, extend=extend.right, border_color=zone_color, bgcolor=color.new(zone_color, 85), text=label_txt, text_color=zone_color, text_size=size.small)

                        ZoneData new_zone = ZoneData.new(bx, zone_top, zone_bottom, zone_type, left_time, display_tf_label, label_txt, small_count, legout_time0)
                        array.unshift(active_zones, new_zone)

                        if array.size(active_zones) > max_zones
                            ZoneData oldest = array.pop(active_zones)
                            if not na(oldest.zone_box)
                                box.delete(oldest.zone_box)

                        ti2_cull_overlaps_same_tf()

// === TI-7: Rejection detection helpers and function ===
within_zone(val, top, bottom) =>
    val <= top and val >= bottom

// === TI-9: position context & entry IDs in arrays (mutable in functions)
var pos_tf_label_arr    = array.new_string()
var pos_zone_type_arr   = array.new_string()
var pos_zone_top_arr    = array.new_float()
var pos_zone_bottom_arr = array.new_float()
var pos_entry_id_arr    = array.new_string()
if barstate.isfirst
    array.push(pos_tf_label_arr, "")
    array.push(pos_zone_type_arr, "")
    array.push(pos_zone_top_arr, na)
    array.push(pos_zone_bottom_arr, na)
    array.push(pos_entry_id_arr, "")

// === TI-3: rectangles to visualize R/SL (one active set) ===
var array<box> pos_tp_box_arr = array.new<box>() // TI-3
var array<box> pos_sl_box_arr = array.new<box>() // TI-3
if barstate.isfirst
    array.push(pos_tp_box_arr, na) // TI-3
    array.push(pos_sl_box_arr, na) // TI-3

set_position_context(tf_lbl, z_type, z_top, z_bottom, entry_id) =>
    array.set(pos_tf_label_arr, 0, tf_lbl)
    array.set(pos_zone_type_arr, 0, z_type)
    array.set(pos_zone_top_arr, 0, z_top)
    array.set(pos_zone_bottom_arr, 0, z_bottom)
    array.set(pos_entry_id_arr, 0, entry_id)

clear_position_boxes() =>
    box btp = array.get(pos_tp_box_arr, 0) // TI-3
    box bsl = array.get(pos_sl_box_arr, 0) // TI-3
    if not na(btp)
        box.delete(btp)
    if not na(bsl)
        box.delete(bsl)
    array.set(pos_tp_box_arr, 0, na) // TI-3
    array.set(pos_sl_box_arr, 0, na) // TI-3

set_position_boxes(entry, tp, sl) =>
    color profit_bg = color.new(color.green, 80) // TI-3
    color loss_bg   = color.new(color.purple, 80) // TI-3
    float top_tp = math.max(entry, tp) // TI-3
    float bot_tp = math.min(entry, tp) // TI-3
    float top_sl = math.max(entry, sl) // TI-3
    float bot_sl = math.min(entry, sl) // TI-3
    box new_tp = box.new(bar_index, top_tp, bar_index, bot_tp, border_color=color.new(color.green, 100), bgcolor=profit_bg) // TI-3
    box new_sl = box.new(bar_index, top_sl, bar_index, bot_sl, border_color=color.new(color.purple, 100), bgcolor=loss_bg) // TI-3
    array.set(pos_tp_box_arr, 0, new_tp) // TI-3
    array.set(pos_sl_box_arr, 0, new_sl) // TI-3

update_position_boxes(entry, tp, sl) =>
    box btp = array.get(pos_tp_box_arr, 0) // TI-3
    box bsl = array.get(pos_sl_box_arr, 0) // TI-3
    if not na(btp)
        box.set_righttop(btp, bar_index, math.max(entry, tp))
        box.set_rightbottom(btp, bar_index, math.min(entry, tp))
    if not na(bsl)
        box.set_righttop(bsl, bar_index, math.max(entry, sl))
        box.set_rightbottom(bsl, bar_index, math.min(entry, sl))

clear_position_context() =>
    clear_position_boxes() // TI-3
    array.set(pos_tf_label_arr, 0, "")
    array.set(pos_zone_type_arr, 0, "")
    array.set(pos_zone_top_arr, 0, na)
    array.set(pos_zone_bottom_arr, 0, na)
    array.set(pos_entry_id_arr, 0, "")

// === TI-9: build entry/exit ID "YYYYMMDDHHMISS.SSS"
zero2(n) => n < 10 ? "0" + str.tostring(n) : str.tostring(n)
zero3(n) => n < 10 ? "00" + str.tostring(n) : n < 100 ? "0" + str.tostring(n) : str.tostring(n)
make_trade_id() =>
    string y  = str.tostring(year)
    string mo = zero2(month)
    string d  = zero2(dayofmonth)
    string h  = zero2(hour)
    string mi = zero2(minute)
    string s  = zero2(second)
    int ms    = int(math.round(time % 1000))
    y + mo + d + h + mi + s + "." + zero3(ms)

// === Signal detector updated for TI-3 EMA confluence, R3 target, 1R→BE, rectangles ===
detect_rejections() =>
    if array.size(active_zones) > 0
        float atr_now = ta.atr(atr_length)
        float min_reject_body = atr_now * rejection_atr_mult
        float body = math.abs(close - open)
        bool green = close > open
        bool red   = close < open

        // Engulfing helper for shorts (current red after green must engulf previous bar) — TI-3
        bool prev_green = close[1] > open[1]
        bool red_engulfs_prev_green = (high >= high[1]) and (low <= low[1])

        for i = 0 to array.size(active_zones) - 1
            ZoneData z = array.get(active_zones, i)
            bool open_in_zone = within_zone(open, z.top, z.bottom) // TI-3
            bool ema_in_zone  = within_zone(ema_fast_val, z.top, z.bottom) or within_zone(ema_slow_val, z.top, z.bottom) // TI-3

            // === DEMAND → B (enter LONG) with EMA confluence — TI-3
            if z.zone_type == "Demand"
                bool cond_long = (ema_fast_val > ema_slow_val) and green and (body >= min_reject_body) and open_in_zone and ema_in_zone // TI-3
                if alerts_on_departure and cond_long
                    // Keep ONLY B label
                    label.new(bar_index, low, "B", color=color.new(color.green, 0), textcolor=color.white, style=label.style_label_up, size=size.tiny)

                    string new_id = make_trade_id()

                    // reverse if short
                    if strategy.position_size < 0
                        string exit_id = array.get(pos_entry_id_arr, 0)
                        strategy.close("SHORT", comment=exit_id)
                        clear_position_context()

                    // enter long (if flat or short just closed)
                    if strategy.position_size <= 0
                        float zone_sz = z.top - z.bottom
                        float sl_long = z.bottom - zone_sz * sl_zone_pct
                        float entry_long = close
                        float r_long = entry_long - sl_long
                        float tp_long = entry_long + 3.0 * r_long
                        strategy.entry("LONG", strategy.long, comment=new_id)
                        strategy.exit("LONG-EXIT", from_entry="LONG", stop=sl_long, limit=tp_long, comment=new_id) // TI-3
                        set_position_context(z.tf_label, z.zone_type, z.top, z.bottom, new_id)
                        set_position_boxes(entry_long, tp_long, sl_long) // TI-3

            // === SUPPLY → S (enter SHORT) with EMA confluence & engulf rule — TI-3
            if z.zone_type == "Supply"
                bool engulf_ok = (not prev_green) or red_engulfs_prev_green // TI-3
                bool cond_short = (ema_fast_val < ema_slow_val) and red and (body >= min_reject_body) and open_in_zone and ema_in_zone and engulf_ok // TI-3
                if alerts_on_departure and cond_short
                    // Keep ONLY S label
                    label.new(bar_index, high, "S", color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.tiny)

                    string new_idS = make_trade_id()

                    // reverse if long
                    if strategy.position_size > 0
                        string exit_id2 = array.get(pos_entry_id_arr, 0)
                        strategy.close("LONG", comment=exit_id2)
                        clear_position_context()

                    // enter short (if flat or long just closed)
                    if strategy.position_size >= 0
                        float zone_szS = z.top - z.bottom
                        float sl_short = z.top + zone_szS * sl_zone_pct
                        float entry_short = close
                        float r_short = sl_short - entry_short
                        float tp_short = entry_short - 3.0 * r_short
                        strategy.entry("SHORT", strategy.short, comment=new_idS)
                        strategy.exit("SHORT-EXIT", from_entry="SHORT", stop=sl_short, limit=tp_short, comment=new_idS) // TI-3
                        set_position_context(z.tf_label, z.zone_type, z.top, z.bottom, new_idS)
                        set_position_boxes(entry_short, tp_short, sl_short) // TI-3

// === TI-3: dynamic risk management — 1R→BE and rectangle updates ===
manage_risk_rr() =>
    if strategy.position_size != 0
        string ztype = array.get(pos_zone_type_arr, 0)
        float ztop   = array.get(pos_zone_top_arr, 0)
        float zbot   = array.get(pos_zone_bottom_arr, 0)
        string eid   = array.get(pos_entry_id_arr, 0)
        if eid != "" and not na(ztop) and not na(zbot)
            float entry = strategy.position_avg_price
            if strategy.position_size > 0
                // LONG
                float init_sl = zbot - (ztop - zbot) * sl_zone_pct
                float R = entry - init_sl
                float tp = entry + 3.0 * R
                float be_trig = entry + R
                float dyn_stop = high >= be_trig ? entry : init_sl
                strategy.exit("LONG-EXIT", from_entry="LONG", stop=dyn_stop, limit=tp, comment=eid)
                update_position_boxes(entry, tp, dyn_stop)
            else
                // SHORT
                float init_sl_s = ztop + (ztop - zbot) * sl_zone_pct
                float R_s = init_sl_s - entry
                float tp_s = entry - 3.0 * R_s
                float be_trig_s = entry - R_s
                float dyn_stop_s = low <= be_trig_s ? entry : init_sl_s
                strategy.exit("SHORT-EXIT", from_entry="SHORT", stop=dyn_stop_s, limit=tp_s, comment=eid)
                update_position_boxes(entry, tp_s, dyn_stop_s)
    else
        // flat: ensure rectangles & context are cleared if any
        if array.get(pos_entry_id_arr, 0) != ""
            clear_position_context()

// === TI-9: exit when reaching opposite zone of the same TF; exit carries the same entry ID
manage_exits_same_tf() =>
    if strategy.position_size != 0
        string ctx_tf   = array.get(pos_tf_label_arr, 0)
        string ctx_type = array.get(pos_zone_type_arr, 0)
        string ctx_id   = array.get(pos_entry_id_arr, 0)
        if ctx_tf != "" and ctx_type != "" and ctx_id != ""
            for i = 0 to array.size(active_zones) - 1
                ZoneData z = array.get(active_zones, i)
                if z.tf_label == ctx_tf
                    // Long: exit at Supply zone (same TF)
                    if strategy.position_size > 0 and z.zone_type == "Supply" and high >= z.bottom
                        strategy.close("LONG", comment=ctx_id)
                        clear_position_context()
                        break
                    // Short: exit at Demand zone (same TF)
                    if strategy.position_size < 0 and z.zone_type == "Demand" and low <= z.top
                        strategy.close("SHORT", comment=ctx_id)
                        clear_position_context()
                        break

// === Main orchestration placed at the bottom ===
main() =>
    if show_60
        detect_mtf_patterns_universal("60", "60M", mtf_open_history_60, mtf_high_history_60, mtf_low_history_60, mtf_close_history_60, mtf_atr_history_60, mtf_time_history_60)
    if show_15
        detect_mtf_patterns_universal("15", "15M", mtf_open_history_15, mtf_high_history_15, mtf_low_history_15, mtf_close_history_15, mtf_atr_history_15, mtf_time_history_15)
    if show_5
        detect_mtf_patterns_universal("5", "5M", mtf_open_history_5, mtf_high_history_5, mtf_low_history_5, mtf_close_history_5, mtf_atr_history_5, mtf_time_history_5)
    if show_ct
        detect_mtf_patterns_universal("", "CT", mtf_open_history_ct, mtf_high_history_ct, mtf_low_history_ct, mtf_close_history_ct, mtf_atr_history_ct, mtf_time_history_ct)

    update_zones()
    detect_rejections()     // TI-3: entries via EMA confluence + R3 target + rectangles + engulf rule (S)
    manage_risk_rr()        // TI-3: dynamic 1R→BE and rectangle updates
    manage_exits_same_tf()  // TI-9: optional exit on opposite zone (same TF) — left intact

// === Run main ===
main()
